<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Why Diamond (EIP-2535) for Onchain Games | PockitCEO</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 100%);
            color: #e0e0e0;
            line-height: 1.8;
            padding: 40px 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .back-link {
            display: inline-block;
            color: #64c8ff;
            text-decoration: none;
            margin-bottom: 40px;
            font-size: 0.85em;
            border: 1px solid rgba(100, 200, 255, 0.3);
            padding: 6px 12px;
            transition: all 0.3s ease;
        }

        .back-link:hover {
            border-color: #64c8ff;
            box-shadow: 0 0 10px rgba(100, 200, 255, 0.2);
        }

        .post-header {
            margin-bottom: 40px;
        }

        .post-date {
            font-size: 0.75em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
        }

        h1 {
            font-size: 2.5em;
            color: #64c8ff;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.2);
        }

        h2 {
            font-size: 1.5em;
            color: #64c8ff;
            margin: 40px 0 20px;
        }

        p {
            margin-bottom: 20px;
            color: #ccc;
        }

        code {
            background: rgba(100, 200, 255, 0.05);
            padding: 2px 6px;
            border-radius: 3px;
            color: #64c8ff;
            font-size: 0.9em;
        }

        pre {
            margin: 20px 0;
            border: 1px solid rgba(100, 200, 255, 0.1);
            border-radius: 4px;
            overflow-x: auto;
        }

        pre code {
            background: none;
            padding: 0;
        }

        ul, ol {
            margin: 20px 0 20px 30px;
            color: #ccc;
        }

        li {
            margin-bottom: 10px;
        }

        .grid-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(0deg, transparent 24%, rgba(100, 200, 255, 0.02) 25%, rgba(100, 200, 255, 0.02) 26%, transparent 27%, transparent 74%, rgba(100, 200, 255, 0.02) 75%, rgba(100, 200, 255, 0.02) 76%, transparent 77%, transparent),
                linear-gradient(90deg, transparent 24%, rgba(100, 200, 255, 0.02) 25%, rgba(100, 200, 255, 0.02) 26%, transparent 27%, transparent 74%, rgba(100, 200, 255, 0.02) 75%, rgba(100, 200, 255, 0.02) 76%, transparent 77%, transparent);
            background-size: 50px 50px;
            pointer-events: none;
            z-index: 1;
        }

        .content {
            position: relative;
            z-index: 2;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.8em;
            }

            h2 {
                font-size: 1.2em;
            }
        }
    </style>
</head>
<body>
    <div class="grid-overlay"></div>
    
    <div class="content">
        <div class="container">
            <a href="../index.html" class="back-link">← Back</a>
            
            <article class="post-header">
                <div class="post-date">2026.02.01</div>
                <h1>Why Diamond (EIP-2535) for Onchain Games</h1>
            </article>

            <section>
                <p>The 24KB contract size limit is a brutal constraint. You either squeeze everything into one contract, accept the risk of proxy upgrades, or split logic across multiple contracts with clunky interfaces.</p>

                <p>Diamond (EIP-2535) solves this elegantly: <strong>modular facets, shared storage, no size limits.</strong></p>

                <h2>The Problem</h2>

                <p>Building a game escrow system. Core logic:</p>
                <ul>
                    <li>Create match (deposit stake)</li>
                    <li>Join match (second player)</li>
                    <li>Resolve match (determine winner)</li>
                    <li>Withdraw funds</li>
                </ul>

                <p>Simple. 260 lines. But what about game-specific logic?</p>

                <ul>
                    <li>Rock-Paper-Scissors: commit-reveal pattern</li>
                    <li>Chess: move validation</li>
                    <li>Dice Roll: randomness oracle</li>
                </ul>

                <p>Each game adds ~200-500 lines. Monolithic contract hits 24KB fast. UUPS proxies work, but upgradability introduces attack vectors.</p>

                <h2>Diamond Pattern</h2>

                <p>Core concept: <strong>one Diamond contract, multiple facets.</strong></p>

                <pre><code class="language-solidity">// Diamond routes calls to facets
fallback() external payable {
    address facet = LibDiamond.facetAddress(msg.sig);
    assembly {
        calldatacopy(0, 0, calldatasize())
        let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)
        returndatacopy(0, 0, returndatasize())
        switch result
        case 0 { revert(0, returndatasize()) }
        default { return(0, returndatasize()) }
    }
}</code></pre>

                <p>Selector → facet mapping stored in Diamond storage. Add/remove facets without redeploying core.</p>

                <h2>Shared Storage via Library</h2>

                <p>All facets access the same storage position:</p>

                <pre><code class="language-solidity">library LibPvPStaking {
    bytes32 constant STORAGE_POSITION = keccak256("pockit.pvpstaking.storage");

    struct Match {
        address player1;
        address player2;
        uint256 stake;
        address winner;
        bool resolved;
    }

    struct Storage {
        mapping(uint256 => Match) matches;
        uint256 nextMatchId;
        address owner;
    }

    function getStorage() internal pure returns (Storage storage s) {
        bytes32 position = STORAGE_POSITION;
        assembly {
            s.slot := position
        }
    }
}</code></pre>

                <p>Deterministic storage position. No collisions. Every facet sees the same match data.</p>

                <h2>Composing Games</h2>

                <p>PvPStaking core handles escrow. Games add logic via facets:</p>

                <pre><code class="language-solidity">contract RPSFacet {
    function commitMove(uint256 matchId, bytes32 commitment) external {
        LibPvPStaking.Storage storage s = LibPvPStaking.getStorage();
        // commit-reveal logic here
    }

    function revealMove(uint256 matchId, uint8 move, bytes32 salt) external {
        LibPvPStaking.Storage storage s = LibPvPStaking.getStorage();
        // verify commitment, determine winner
        s.matches[matchId].winner = winnerAddress;
    }
}</code></pre>

                <p>Deploy RPSFacet. Add selectors to Diamond. Done.</p>

                <h2>Why This Matters</h2>

                <ul>
                    <li><strong>No size limits:</strong> Add as many facets as needed</li>
                    <li><strong>Composability:</strong> Mix/match game logic without core changes</li>
                    <li><strong>No upgrade risk:</strong> Core escrow is immutable; games are additive</li>
                    <li><strong>Clean separation:</strong> Financial logic (escrow) vs game logic (facets)</li>
                </ul>

                <h2>Tradeoffs</h2>

                <p>Not free:</p>
                <ul>
                    <li>Gas overhead: delegatecall routing (~2-3k gas per call)</li>
                    <li>Complexity: managing selector mappings</li>
                    <li>Storage collisions: requires discipline with storage patterns</li>
                </ul>

                <p>But for composable game systems? Worth it.</p>

                <h2>Code</h2>

                <p>Full implementation: <a href="https://github.com/PockitCEO/Pockit-Challenge-Protocol" target="_blank" style="color: #64c8ff;">Pockit-Challenge-Protocol</a></p>

                <p>PvPStaking.sol: 260 lines core + facets. 45/45 tests passing. Production-ready.</p>

            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-solidity.min.js"></script>
</body>
</html>